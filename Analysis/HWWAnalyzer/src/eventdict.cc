//
// File generated by rootcint at Tue Nov 10 17:50:32 2009

// Do NOT change. Changes will be lost next time file is generated
//

#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "eventdict.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void mytrack_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_mytrack(void *p = 0);
   static void *newArray_mytrack(Long_t size, void *p);
   static void delete_mytrack(void *p);
   static void deleteArray_mytrack(void *p);
   static void destruct_mytrack(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::mytrack*)
   {
      ::mytrack *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::mytrack >(0);
      static ::ROOT::TGenericClassInfo 
         instance("mytrack", ::mytrack::Class_Version(), "/home/xjanssen/cms/HWW/CMSSW_3_2_6/src/Analysis/HWWAnalyzer/src/../../../Analysis/HWWAnalyzer/interface/mytrack.h", 6,
                  typeid(::mytrack), DefineBehavior(ptr, ptr),
                  &::mytrack::Dictionary, isa_proxy, 4,
                  sizeof(::mytrack) );
      instance.SetNew(&new_mytrack);
      instance.SetNewArray(&newArray_mytrack);
      instance.SetDelete(&delete_mytrack);
      instance.SetDeleteArray(&deleteArray_mytrack);
      instance.SetDestructor(&destruct_mytrack);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::mytrack*)
   {
      return GenerateInitInstanceLocal((::mytrack*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::mytrack*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void myobject_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_myobject(void *p = 0);
   static void *newArray_myobject(Long_t size, void *p);
   static void delete_myobject(void *p);
   static void deleteArray_myobject(void *p);
   static void destruct_myobject(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::myobject*)
   {
      ::myobject *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::myobject >(0);
      static ::ROOT::TGenericClassInfo 
         instance("myobject", ::myobject::Class_Version(), "/home/xjanssen/cms/HWW/CMSSW_3_2_6/src/Analysis/HWWAnalyzer/src/../../../Analysis/HWWAnalyzer/interface/myobject.h", 8,
                  typeid(::myobject), DefineBehavior(ptr, ptr),
                  &::myobject::Dictionary, isa_proxy, 4,
                  sizeof(::myobject) );
      instance.SetNew(&new_myobject);
      instance.SetNewArray(&newArray_myobject);
      instance.SetDelete(&delete_myobject);
      instance.SetDeleteArray(&deleteArray_myobject);
      instance.SetDestructor(&destruct_myobject);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::myobject*)
   {
      return GenerateInitInstanceLocal((::myobject*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::myobject*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void myevent_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void *new_myevent(void *p = 0);
   static void *newArray_myevent(Long_t size, void *p);
   static void delete_myevent(void *p);
   static void deleteArray_myevent(void *p);
   static void destruct_myevent(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::myevent*)
   {
      ::myevent *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TInstrumentedIsAProxy< ::myevent >(0);
      static ::ROOT::TGenericClassInfo 
         instance("myevent", ::myevent::Class_Version(), "/home/xjanssen/cms/HWW/CMSSW_3_2_6/src/Analysis/HWWAnalyzer/src/../../../Analysis/HWWAnalyzer/interface/myevent.h", 11,
                  typeid(::myevent), DefineBehavior(ptr, ptr),
                  &::myevent::Dictionary, isa_proxy, 4,
                  sizeof(::myevent) );
      instance.SetNew(&new_myevent);
      instance.SetNewArray(&newArray_myevent);
      instance.SetDelete(&delete_myevent);
      instance.SetDeleteArray(&deleteArray_myevent);
      instance.SetDestructor(&destruct_myevent);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::myevent*)
   {
      return GenerateInitInstanceLocal((::myevent*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::myevent*)0x0); R__UseDummy(_R__UNIQUE_(Init));
} // end of namespace ROOT

namespace ROOT {
   void vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator_Dictionary();
   static void *new_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(void *p = 0);
   static void *newArray_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(Long_t size, void *p);
   static void delete_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(void *p);
   static void deleteArray_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(void *p);
   static void destruct_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::vector<myobject,allocator<myobject> >::iterator*)
   {
      ::vector<myobject,allocator<myobject> >::iterator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::vector<myobject,allocator<myobject> >::iterator),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<myobject,allocator<myobject> >::iterator", "/afs/cern.ch/cms/sw/slc4_ia32_gcc345/lcg/root/5.22.00a-cms18/cint/cint/lib/prec_stl/vector", 206,
                  typeid(::vector<myobject,allocator<myobject> >::iterator), DefineBehavior(ptr, ptr),
                  0, &vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator_Dictionary, isa_proxy, 0,
                  sizeof(::vector<myobject,allocator<myobject> >::iterator) );
      instance.SetNew(&new_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator);
      instance.SetNewArray(&newArray_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator);
      instance.SetDelete(&delete_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator);
      instance.SetDeleteArray(&deleteArray_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator);
      instance.SetDestructor(&destruct_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::vector<myobject,allocator<myobject> >::iterator*)
   {
      return GenerateInitInstanceLocal((::vector<myobject,allocator<myobject> >::iterator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::vector<myobject,allocator<myobject> >::iterator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::vector<myobject,allocator<myobject> >::iterator*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator_Dictionary();
   static void *new_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(void *p = 0);
   static void *newArray_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(Long_t size, void *p);
   static void delete_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(void *p);
   static void deleteArray_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(void *p);
   static void destruct_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::vector<mytrack,allocator<mytrack> >::iterator*)
   {
      ::vector<mytrack,allocator<mytrack> >::iterator *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::vector<mytrack,allocator<mytrack> >::iterator),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<mytrack,allocator<mytrack> >::iterator", "/afs/cern.ch/cms/sw/slc4_ia32_gcc345/lcg/root/5.22.00a-cms18/cint/cint/lib/prec_stl/vector", 206,
                  typeid(::vector<mytrack,allocator<mytrack> >::iterator), DefineBehavior(ptr, ptr),
                  0, &vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator_Dictionary, isa_proxy, 0,
                  sizeof(::vector<mytrack,allocator<mytrack> >::iterator) );
      instance.SetNew(&new_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator);
      instance.SetNewArray(&newArray_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator);
      instance.SetDelete(&delete_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator);
      instance.SetDeleteArray(&deleteArray_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator);
      instance.SetDestructor(&destruct_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::vector<mytrack,allocator<mytrack> >::iterator*)
   {
      return GenerateInitInstanceLocal((::vector<mytrack,allocator<mytrack> >::iterator*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::vector<mytrack,allocator<mytrack> >::iterator*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::vector<mytrack,allocator<mytrack> >::iterator*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
TClass *mytrack::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *mytrack::Class_Name()
{
   return "mytrack";
}

//______________________________________________________________________________
const char *mytrack::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::mytrack*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int mytrack::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::mytrack*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void mytrack::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::mytrack*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *mytrack::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::mytrack*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *myobject::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *myobject::Class_Name()
{
   return "myobject";
}

//______________________________________________________________________________
const char *myobject::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::myobject*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int myobject::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::myobject*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void myobject::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::myobject*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *myobject::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::myobject*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *myevent::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *myevent::Class_Name()
{
   return "myevent";
}

//______________________________________________________________________________
const char *myevent::ImplFileName()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::myevent*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int myevent::ImplFileLine()
{
   return ::ROOT::GenerateInitInstanceLocal((const ::myevent*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void myevent::Dictionary()
{
   fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::myevent*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *myevent::Class()
{
   if (!fgIsA) fgIsA = ::ROOT::GenerateInitInstanceLocal((const ::myevent*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
void mytrack::Streamer(TBuffer &R__b)
{
   // Stream an object of class mytrack.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(mytrack::Class(),this);
   } else {
      R__b.WriteClassBuffer(mytrack::Class(),this);
   }
}

//______________________________________________________________________________
void mytrack::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class mytrack.
      TClass *R__cl = ::mytrack::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "px", &px);
      R__insp.Inspect(R__cl, R__parent, "py", &py);
      R__insp.Inspect(R__cl, R__parent, "pz", &pz);
      R__insp.Inspect(R__cl, R__parent, "pt", &pt);
      R__insp.Inspect(R__cl, R__parent, "eta", &eta);
      R__insp.Inspect(R__cl, R__parent, "phi", &phi);
      R__insp.Inspect(R__cl, R__parent, "charge", &charge);
      R__insp.Inspect(R__cl, R__parent, "E", &E);
      R__insp.Inspect(R__cl, R__parent, "ipx", &ipx);
      R__insp.Inspect(R__cl, R__parent, "ipy", &ipy);
      R__insp.Inspect(R__cl, R__parent, "iperr_x", &iperr_x);
      R__insp.Inspect(R__cl, R__parent, "iperr_y", &iperr_y);
      R__insp.Inspect(R__cl, R__parent, "Vz", &Vz);
      R__insp.Inspect(R__cl, R__parent, "Chi2", &Chi2);
      R__insp.Inspect(R__cl, R__parent, "Ndof", &Ndof);
      R__insp.Inspect(R__cl, R__parent, "VHits", &VHits);
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_mytrack(void *p) {
      return  p ? new(p) ::mytrack : new ::mytrack;
   }
   static void *newArray_mytrack(Long_t nElements, void *p) {
      return p ? new(p) ::mytrack[nElements] : new ::mytrack[nElements];
   }
   // Wrapper around operator delete
   static void delete_mytrack(void *p) {
      delete ((::mytrack*)p);
   }
   static void deleteArray_mytrack(void *p) {
      delete [] ((::mytrack*)p);
   }
   static void destruct_mytrack(void *p) {
      typedef ::mytrack current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::mytrack

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::vector<mytrack,allocator<mytrack> >::iterator : new ::vector<mytrack,allocator<mytrack> >::iterator;
   }
   static void *newArray_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::vector<mytrack,allocator<mytrack> >::iterator[nElements] : new ::vector<mytrack,allocator<mytrack> >::iterator[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(void *p) {
      delete ((::vector<mytrack,allocator<mytrack> >::iterator*)p);
   }
   static void deleteArray_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(void *p) {
      delete [] ((::vector<mytrack,allocator<mytrack> >::iterator*)p);
   }
   static void destruct_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(void *p) {
      typedef ::vector<mytrack,allocator<mytrack> >::iterator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::vector<mytrack,allocator<mytrack> >::iterator

//______________________________________________________________________________
void myobject::Streamer(TBuffer &R__b)
{
   // Stream an object of class myobject.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(myobject::Class(),this);
   } else {
      R__b.WriteClassBuffer(myobject::Class(),this);
   }
}

//______________________________________________________________________________
void myobject::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class myobject.
      TClass *R__cl = ::myobject::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "pt", &pt);
      R__insp.Inspect(R__cl, R__parent, "eta", &eta);
      R__insp.Inspect(R__cl, R__parent, "phi", &phi);
      R__insp.Inspect(R__cl, R__parent, "charge", &charge);
      R__insp.Inspect(R__cl, R__parent, "E", &E);
      R__insp.Inspect(R__cl, R__parent, "px", &px);
      R__insp.Inspect(R__cl, R__parent, "py", &py);
      R__insp.Inspect(R__cl, R__parent, "pz", &pz);
      R__insp.Inspect(R__cl, R__parent, "corrpt", &corrpt);
      R__insp.Inspect(R__cl, R__parent, "corrpx", &corrpx);
      R__insp.Inspect(R__cl, R__parent, "corrpy", &corrpy);
      R__insp.Inspect(R__cl, R__parent, "corrphi", &corrphi);
      R__insp.Inspect(R__cl, R__parent, "DepositR03Ecal", &DepositR03Ecal);
      R__insp.Inspect(R__cl, R__parent, "DepositR03Hcal", &DepositR03Hcal);
      R__insp.Inspect(R__cl, R__parent, "DepositR03TrackerOfficial", &DepositR03TrackerOfficial);
      R__insp.Inspect(R__cl, R__parent, "alpha", &alpha);
      R__insp.Inspect(R__cl, R__parent, "discriminator", &discriminator);
      R__insp.Inspect(R__cl, R__parent, "HcalIsolation", &HcalIsolation);
      R__insp.Inspect(R__cl, R__parent, "EcalIsolation", &EcalIsolation);
      R__insp.Inspect(R__cl, R__parent, "TrackerIsolation", &TrackerIsolation);
      R__insp.Inspect(R__cl, R__parent, "EcalJurassicIsolation", &EcalJurassicIsolation);
      R__insp.Inspect(R__cl, R__parent, "classification", &classification);
      R__insp.Inspect(R__cl, R__parent, "HoverE", &HoverE);
      R__insp.Inspect(R__cl, R__parent, "EseedPout", &EseedPout);
      R__insp.Inspect(R__cl, R__parent, "dEta", &dEta);
      R__insp.Inspect(R__cl, R__parent, "dPhi", &dPhi);
      R__insp.Inspect(R__cl, R__parent, "s9s25", &s9s25);
      R__insp.Inspect(R__cl, R__parent, "sigmaEtaEta", &sigmaEtaEta);
      R__insp.Inspect(R__cl, R__parent, "eidTight", &eidTight);
      R__insp.Inspect(R__cl, R__parent, "GlobalMuonPromptTight", &GlobalMuonPromptTight);
      R__insp.Inspect(R__cl, R__parent, "TMOneStationLoose", &TMOneStationLoose);
      R__insp.Inspect(R__cl, R__parent, "TM2DCompatibilityLoose", &TM2DCompatibilityLoose);
      R__insp.Inspect(R__cl, R__parent, "name", (void*)&name);
      ::ROOT::GenericShowMembers("string", (void*)&name, R__insp, strcat(R__parent,"name."),false);
      R__parent[R__ncp] = 0;
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_myobject(void *p) {
      return  p ? new(p) ::myobject : new ::myobject;
   }
   static void *newArray_myobject(Long_t nElements, void *p) {
      return p ? new(p) ::myobject[nElements] : new ::myobject[nElements];
   }
   // Wrapper around operator delete
   static void delete_myobject(void *p) {
      delete ((::myobject*)p);
   }
   static void deleteArray_myobject(void *p) {
      delete [] ((::myobject*)p);
   }
   static void destruct_myobject(void *p) {
      typedef ::myobject current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::myobject

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::vector<myobject,allocator<myobject> >::iterator : new ::vector<myobject,allocator<myobject> >::iterator;
   }
   static void *newArray_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::vector<myobject,allocator<myobject> >::iterator[nElements] : new ::vector<myobject,allocator<myobject> >::iterator[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(void *p) {
      delete ((::vector<myobject,allocator<myobject> >::iterator*)p);
   }
   static void deleteArray_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(void *p) {
      delete [] ((::vector<myobject,allocator<myobject> >::iterator*)p);
   }
   static void destruct_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(void *p) {
      typedef ::vector<myobject,allocator<myobject> >::iterator current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::vector<myobject,allocator<myobject> >::iterator

//______________________________________________________________________________
void myevent::Streamer(TBuffer &R__b)
{
   // Stream an object of class myevent.

   if (R__b.IsReading()) {
      R__b.ReadClassBuffer(myevent::Class(),this);
   } else {
      R__b.WriteClassBuffer(myevent::Class(),this);
   }
}

//______________________________________________________________________________
void myevent::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class myevent.
      TClass *R__cl = ::myevent::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "RecJets", (void*)&RecJets);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&RecJets, R__insp, strcat(R__parent,"RecJets."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "RecPFJetsIC5", (void*)&RecPFJetsIC5);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&RecPFJetsIC5, R__insp, strcat(R__parent,"RecPFJetsIC5."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "RecPFJetsSC5", (void*)&RecPFJetsSC5);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&RecPFJetsSC5, R__insp, strcat(R__parent,"RecPFJetsSC5."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "PreSelectedElectrons", (void*)&PreSelectedElectrons);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&PreSelectedElectrons, R__insp, strcat(R__parent,"PreSelectedElectrons."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "PreSelectedMuons", (void*)&PreSelectedMuons);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&PreSelectedMuons, R__insp, strcat(R__parent,"PreSelectedMuons."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "RecMet", (void*)&RecMet);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&RecMet, R__insp, strcat(R__parent,"RecMet."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "RecPFMet", (void*)&RecPFMet);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&RecPFMet, R__insp, strcat(R__parent,"RecPFMet."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "GenMet", (void*)&GenMet);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&GenMet, R__insp, strcat(R__parent,"GenMet."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "GenJets", (void*)&GenJets);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&GenJets, R__insp, strcat(R__parent,"GenJets."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "MCBjets", (void*)&MCBjets);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&MCBjets, R__insp, strcat(R__parent,"MCBjets."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "MCNus", (void*)&MCNus);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&MCNus, R__insp, strcat(R__parent,"MCNus."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "GenParticle", (void*)&GenParticle);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&GenParticle, R__insp, strcat(R__parent,"GenParticle."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "Vertex", (void*)&Vertex);
      ::ROOT::GenericShowMembers("vector<myobject>", (void*)&Vertex, R__insp, strcat(R__parent,"Vertex."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "AllTracks", (void*)&AllTracks);
      ::ROOT::GenericShowMembers("vector<mytrack>", (void*)&AllTracks, R__insp, strcat(R__parent,"AllTracks."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "PDF_weights1", (void*)&PDF_weights1);
      ::ROOT::GenericShowMembers("vector<double>", (void*)&PDF_weights1, R__insp, strcat(R__parent,"PDF_weights1."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "PDF_weights2", (void*)&PDF_weights2);
      ::ROOT::GenericShowMembers("vector<double>", (void*)&PDF_weights2, R__insp, strcat(R__parent,"PDF_weights2."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "PDF_weights3", (void*)&PDF_weights3);
      ::ROOT::GenericShowMembers("vector<double>", (void*)&PDF_weights3, R__insp, strcat(R__parent,"PDF_weights3."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "PDF_weights4", (void*)&PDF_weights4);
      ::ROOT::GenericShowMembers("vector<double>", (void*)&PDF_weights4, R__insp, strcat(R__parent,"PDF_weights4."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "product_central_1", &product_central_1);
      R__insp.Inspect(R__cl, R__parent, "product_central_2", &product_central_2);
      R__insp.Inspect(R__cl, R__parent, "product_central_3", &product_central_3);
      R__insp.Inspect(R__cl, R__parent, "product_central_4", &product_central_4);
      R__insp.Inspect(R__cl, R__parent, "x_1", &x_1);
      R__insp.Inspect(R__cl, R__parent, "x_2", &x_2);
      R__insp.Inspect(R__cl, R__parent, "Q_scale", &Q_scale);
      R__insp.Inspect(R__cl, R__parent, "f1", &f1);
      R__insp.Inspect(R__cl, R__parent, "f2", &f2);
      R__insp.Inspect(R__cl, R__parent, "pdf_1", &pdf_1);
      R__insp.Inspect(R__cl, R__parent, "pdf_2", &pdf_2);
      R__insp.Inspect(R__cl, R__parent, "HLT", (void*)&HLT);
      ::ROOT::GenericShowMembers("map<string,int>", (void*)&HLT, R__insp, strcat(R__parent,"HLT."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "weight", &weight);
      R__insp.Inspect(R__cl, R__parent, "KFactor", &KFactor);
      R__insp.Inspect(R__cl, R__parent, "ProcessId", &ProcessId);
      R__insp.Inspect(R__cl, R__parent, "PtHat", &PtHat);
      R__insp.Inspect(R__cl, R__parent, "PreselectionMarker", &PreselectionMarker);
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Wrappers around operator new
   static void *new_myevent(void *p) {
      return  p ? new(p) ::myevent : new ::myevent;
   }
   static void *newArray_myevent(Long_t nElements, void *p) {
      return p ? new(p) ::myevent[nElements] : new ::myevent[nElements];
   }
   // Wrapper around operator delete
   static void delete_myevent(void *p) {
      delete ((::myevent*)p);
   }
   static void deleteArray_myevent(void *p) {
      delete [] ((::myevent*)p);
   }
   static void destruct_myevent(void *p) {
      typedef ::myevent current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::myevent

namespace ROOT {
   void maplEstringcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void maplEstringcOintgR_Dictionary();
   static void *new_maplEstringcOintgR(void *p = 0);
   static void *newArray_maplEstringcOintgR(Long_t size, void *p);
   static void delete_maplEstringcOintgR(void *p);
   static void deleteArray_maplEstringcOintgR(void *p);
   static void destruct_maplEstringcOintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<string,int>*)
   {
      map<string,int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<string,int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("map<string,int>", -2, "map.dll", 0,
                  typeid(map<string,int>), DefineBehavior(ptr, ptr),
                  0, &maplEstringcOintgR_Dictionary, isa_proxy, 0,
                  sizeof(map<string,int>) );
      instance.SetNew(&new_maplEstringcOintgR);
      instance.SetNewArray(&newArray_maplEstringcOintgR);
      instance.SetDelete(&delete_maplEstringcOintgR);
      instance.SetDeleteArray(&deleteArray_maplEstringcOintgR);
      instance.SetDestructor(&destruct_maplEstringcOintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<string,int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<string,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void maplEstringcOintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const map<string,int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEstringcOintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) map<string,int> : new map<string,int>;
   }
   static void *newArray_maplEstringcOintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) map<string,int>[nElements] : new map<string,int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEstringcOintgR(void *p) {
      delete ((map<string,int>*)p);
   }
   static void deleteArray_maplEstringcOintgR(void *p) {
      delete [] ((map<string,int>*)p);
   }
   static void destruct_maplEstringcOintgR(void *p) {
      typedef map<string,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<string,int>

namespace ROOT {
   void vectorlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEdoublegR_Dictionary();
   static void *new_vectorlEdoublegR(void *p = 0);
   static void *newArray_vectorlEdoublegR(Long_t size, void *p);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<double>*)
   {
      vector<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<double>", -2, "vector.dll", 0,
                  typeid(vector<double>), DefineBehavior(ptr, ptr),
                  0, &vectorlEdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double>[nElements] : new vector<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<double>

namespace ROOT {
   void vectorlEmyobjectgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEmyobjectgR_Dictionary();
   static void *new_vectorlEmyobjectgR(void *p = 0);
   static void *newArray_vectorlEmyobjectgR(Long_t size, void *p);
   static void delete_vectorlEmyobjectgR(void *p);
   static void deleteArray_vectorlEmyobjectgR(void *p);
   static void destruct_vectorlEmyobjectgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<myobject>*)
   {
      vector<myobject> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<myobject>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<myobject>", -2, "/afs/cern.ch/cms/sw/slc4_ia32_gcc345/lcg/root/5.22.00a-cms18/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<myobject>), DefineBehavior(ptr, ptr),
                  0, &vectorlEmyobjectgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<myobject>) );
      instance.SetNew(&new_vectorlEmyobjectgR);
      instance.SetNewArray(&newArray_vectorlEmyobjectgR);
      instance.SetDelete(&delete_vectorlEmyobjectgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmyobjectgR);
      instance.SetDestructor(&destruct_vectorlEmyobjectgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<myobject> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<myobject>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEmyobjectgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<myobject>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmyobjectgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<myobject> : new vector<myobject>;
   }
   static void *newArray_vectorlEmyobjectgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<myobject>[nElements] : new vector<myobject>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmyobjectgR(void *p) {
      delete ((vector<myobject>*)p);
   }
   static void deleteArray_vectorlEmyobjectgR(void *p) {
      delete [] ((vector<myobject>*)p);
   }
   static void destruct_vectorlEmyobjectgR(void *p) {
      typedef vector<myobject> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<myobject>

namespace ROOT {
   void vectorlEmytrackgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEmytrackgR_Dictionary();
   static void *new_vectorlEmytrackgR(void *p = 0);
   static void *newArray_vectorlEmytrackgR(Long_t size, void *p);
   static void delete_vectorlEmytrackgR(void *p);
   static void deleteArray_vectorlEmytrackgR(void *p);
   static void destruct_vectorlEmytrackgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<mytrack>*)
   {
      vector<mytrack> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<mytrack>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<mytrack>", -2, "/afs/cern.ch/cms/sw/slc4_ia32_gcc345/lcg/root/5.22.00a-cms18/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<mytrack>), DefineBehavior(ptr, ptr),
                  0, &vectorlEmytrackgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<mytrack>) );
      instance.SetNew(&new_vectorlEmytrackgR);
      instance.SetNewArray(&newArray_vectorlEmytrackgR);
      instance.SetDelete(&delete_vectorlEmytrackgR);
      instance.SetDeleteArray(&deleteArray_vectorlEmytrackgR);
      instance.SetDestructor(&destruct_vectorlEmytrackgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<mytrack> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<mytrack>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEmytrackgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<mytrack>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEmytrackgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<mytrack> : new vector<mytrack>;
   }
   static void *newArray_vectorlEmytrackgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<mytrack>[nElements] : new vector<mytrack>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEmytrackgR(void *p) {
      delete ((vector<mytrack>*)p);
   }
   static void deleteArray_vectorlEmytrackgR(void *p) {
      delete [] ((vector<mytrack>*)p);
   }
   static void destruct_vectorlEmytrackgR(void *p) {
      typedef vector<mytrack> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<mytrack>

/********************************************************
* eventdict.cc
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 1)
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableeventdict();

extern "C" void G__set_cpp_environmenteventdict() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("Analysis/HWWAnalyzer/interface/mytrack.h");
  G__add_compiledheader("Analysis/HWWAnalyzer/interface/myobject.h");
  G__add_compiledheader("Analysis/HWWAnalyzer/interface/myevent.h");
  G__cpp_reset_tagtableeventdict();
}
#include <new>
extern "C" int G__cpp_dllreveventdict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* mytrack */
static int G__eventdict_189_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   mytrack* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new mytrack[n];
     } else {
       p = new((void*) gvp) mytrack[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new mytrack;
     } else {
       p = new((void*) gvp) mytrack;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_mytrack));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_189_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) mytrack::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_189_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) mytrack::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_189_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) mytrack::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_189_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      mytrack::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_189_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((mytrack*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_189_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) mytrack::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_189_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) mytrack::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_189_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) mytrack::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_189_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) mytrack::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__eventdict_189_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   mytrack* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new mytrack(*(mytrack*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_mytrack));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef mytrack G__Tmytrack;
static int G__eventdict_189_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (mytrack*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((mytrack*) (soff+(sizeof(mytrack)*i)))->~G__Tmytrack();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (mytrack*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((mytrack*) (soff))->~G__Tmytrack();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__eventdict_189_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   mytrack* dest = (mytrack*) G__getstructoffset();
   *dest = *(mytrack*) libp->para[0].ref;
   const mytrack& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* myobject */
static int G__eventdict_190_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   myobject* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new myobject[n];
     } else {
       p = new((void*) gvp) myobject[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new myobject;
     } else {
       p = new((void*) gvp) myobject;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_myobject));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_190_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) myobject::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_190_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) myobject::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_190_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) myobject::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_190_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      myobject::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_190_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((myobject*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_190_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) myobject::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_190_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) myobject::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_190_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) myobject::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_190_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) myobject::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__eventdict_190_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   myobject* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new myobject(*(myobject*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_myobject));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef myobject G__Tmyobject;
static int G__eventdict_190_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (myobject*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((myobject*) (soff+(sizeof(myobject)*i)))->~G__Tmyobject();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (myobject*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((myobject*) (soff))->~G__Tmyobject();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__eventdict_190_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   myobject* dest = (myobject*) G__getstructoffset();
   *dest = *(myobject*) libp->para[0].ref;
   const myobject& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* myevent */
static int G__eventdict_426_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   myevent* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new myevent[n];
     } else {
       p = new((void*) gvp) myevent[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new myevent;
     } else {
       p = new((void*) gvp) myevent;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_myevent));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_426_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) myevent::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_426_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) myevent::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_426_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 115, (long) myevent::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_426_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      myevent::Dictionary();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_426_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((myevent*) G__getstructoffset())->StreamerNVirtual(*(TBuffer*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_426_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) myevent::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_426_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) myevent::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_426_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) myevent::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_426_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) myevent::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__eventdict_426_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   myevent* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new myevent(*(myevent*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_myevent));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef myevent G__Tmyevent;
static int G__eventdict_426_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 1
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (myevent*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((myevent*) (soff+(sizeof(myevent)*i)))->~G__Tmyevent();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (myevent*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((myevent*) (soff))->~G__Tmyevent();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__eventdict_426_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   myevent* dest = (myevent*) G__getstructoffset();
   *dest = *(myevent*) libp->para[0].ref;
   const myevent& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<myobject,allocator<myobject> > */
static int G__eventdict_428_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const myobject& obj = ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->at((vector<myobject,allocator<myobject> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<myobject,allocator<myobject> >::iterator* pobj;
         vector<myobject,allocator<myobject> >::iterator xobj = ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->begin();
         pobj = new vector<myobject,allocator<myobject> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<myobject,allocator<myobject> >::iterator* pobj;
         vector<myobject,allocator<myobject> >::iterator xobj = ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->end();
         pobj = new vector<myobject,allocator<myobject> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<myobject,allocator<myobject> >::reverse_iterator* pobj;
         vector<myobject,allocator<myobject> >::reverse_iterator xobj = ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->rbegin();
         pobj = new vector<myobject,allocator<myobject> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<myobject,allocator<myobject> >::reverse_iterator* pobj;
         vector<myobject,allocator<myobject> >::reverse_iterator xobj = ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->rend();
         pobj = new vector<myobject,allocator<myobject> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<myobject,allocator<myobject> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<myobject,allocator<myobject> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->resize((vector<myobject,allocator<myobject> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->resize((vector<myobject,allocator<myobject> >::size_type) G__int(libp->para[0]), *((myobject*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<myobject,allocator<myobject> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<myobject,allocator<myobject> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const myobject& obj = ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->operator[]((vector<myobject,allocator<myobject> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<myobject,allocator<myobject> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<myobject,allocator<myobject> >[n];
     } else {
       p = new((void*) gvp) vector<myobject,allocator<myobject> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<myobject,allocator<myobject> >;
     } else {
       p = new((void*) gvp) vector<myobject,allocator<myobject> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<myobject,allocator<myobject> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<myobject,allocator<myobject> >((vector<myobject,allocator<myobject> >::size_type) G__int(libp->para[0]), *(myobject*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<myobject,allocator<myobject> >((vector<myobject,allocator<myobject> >::size_type) G__int(libp->para[0]), *(myobject*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<myobject,allocator<myobject> >((vector<myobject,allocator<myobject> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<myobject,allocator<myobject> >((vector<myobject,allocator<myobject> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<myobject,allocator<myobject> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<myobject,allocator<myobject> >(*(vector<myobject,allocator<myobject> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<myobject,allocator<myobject> >(*(vector<myobject,allocator<myobject> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<myobject,allocator<myobject> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<myobject,allocator<myobject> >(*((vector<myobject,allocator<myobject> >::const_iterator*) G__int(libp->para[0])), *((vector<myobject,allocator<myobject> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<myobject,allocator<myobject> >(*((vector<myobject,allocator<myobject> >::const_iterator*) G__int(libp->para[0])), *((vector<myobject,allocator<myobject> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<myobject,allocator<myobject> >& obj = ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->operator=(*(vector<myobject,allocator<myobject> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->reserve((vector<myobject,allocator<myobject> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const myobject& obj = ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const myobject& obj = ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->push_back(*(myobject*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->swap(*(vector<myobject,allocator<myobject> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<myobject,allocator<myobject> >::iterator* pobj;
         vector<myobject,allocator<myobject> >::iterator xobj = ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->insert(*((vector<myobject,allocator<myobject> >::iterator*) G__int(libp->para[0])), *(myobject*) libp->para[1].ref);
         pobj = new vector<myobject,allocator<myobject> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->insert(*((vector<myobject,allocator<myobject> >::iterator*) G__int(libp->para[0])), *((vector<myobject,allocator<myobject> >::const_iterator*) G__int(libp->para[1]))
, *((vector<myobject,allocator<myobject> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->insert(*((vector<myobject,allocator<myobject> >::iterator*) G__int(libp->para[0])), (vector<myobject,allocator<myobject> >::size_type) G__int(libp->para[1])
, *(myobject*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->erase(*((vector<myobject,allocator<myobject> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->erase(*((vector<myobject,allocator<myobject> >::iterator*) G__int(libp->para[0])), *((vector<myobject,allocator<myobject> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_428_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<myobject,allocator<myobject> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<myobject,allocator<myobject> > G__TvectorlEmyobjectcOallocatorlEmyobjectgRsPgR;
static int G__eventdict_428_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<myobject,allocator<myobject> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<myobject,allocator<myobject> >*) (soff+(sizeof(vector<myobject,allocator<myobject> >)*i)))->~G__TvectorlEmyobjectcOallocatorlEmyobjectgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<myobject,allocator<myobject> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<myobject,allocator<myobject> >*) (soff))->~G__TvectorlEmyobjectcOallocatorlEmyobjectgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<myobject,allocator<myobject> >::iterator */
static int G__eventdict_429_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<myobject,allocator<myobject> >::iterator* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<myobject,allocator<myobject> >::iterator[n];
     } else {
       p = new((void*) gvp) vector<myobject,allocator<myobject> >::iterator[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<myobject,allocator<myobject> >::iterator;
     } else {
       p = new((void*) gvp) vector<myobject,allocator<myobject> >::iterator;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<myobject,allocator<myobject> >::iterator* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<myobject,allocator<myobject> >::iterator(libp->para[0].ref ? *(const vector<myobject,allocator<myobject> >::iterator::pointer*) libp->para[0].ref : *(const vector<myobject,allocator<myobject> >::iterator::pointer*) (&G__Mlong(libp->para[0])));
   } else {
     p = new((void*) gvp) vector<myobject,allocator<myobject> >::iterator(libp->para[0].ref ? *(const vector<myobject,allocator<myobject> >::iterator::pointer*) libp->para[0].ref : *(const vector<myobject,allocator<myobject> >::iterator::pointer*) (&G__Mlong(libp->para[0])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<myobject,allocator<myobject> >::iterator::reference obj = ((const vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator*();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<myobject,allocator<myobject> >::iterator& obj = ((vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator++();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<myobject,allocator<myobject> >::iterator* pobj;
         vector<myobject,allocator<myobject> >::iterator xobj = ((vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator++((int) G__int(libp->para[0]));
         pobj = new vector<myobject,allocator<myobject> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<myobject,allocator<myobject> >::iterator& obj = ((vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator--();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<myobject,allocator<myobject> >::iterator* pobj;
         vector<myobject,allocator<myobject> >::iterator xobj = ((vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator--((int) G__int(libp->para[0]));
         pobj = new vector<myobject,allocator<myobject> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<myobject,allocator<myobject> >::iterator::reference obj = ((const vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator[](*(vector<myobject,allocator<myobject> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<myobject,allocator<myobject> >::iterator& obj = ((vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator+=(*(vector<myobject,allocator<myobject> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<myobject,allocator<myobject> >::iterator* pobj;
         const vector<myobject,allocator<myobject> >::iterator xobj = ((const vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator+(*(vector<myobject,allocator<myobject> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         pobj = new vector<myobject,allocator<myobject> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<myobject,allocator<myobject> >::iterator& obj = ((vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator-=(*(vector<myobject,allocator<myobject> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<myobject,allocator<myobject> >::iterator* pobj;
         const vector<myobject,allocator<myobject> >::iterator xobj = ((const vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator-(*(vector<myobject,allocator<myobject> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         pobj = new vector<myobject,allocator<myobject> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<myobject,allocator<myobject> >::iterator::pointer& obj = ((const vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->base();
         result7->ref = (long) (&obj);
         G__letint(result7, 'U', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_429_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<myobject,allocator<myobject> >::iterator* pobj;
         vector<myobject,allocator<myobject> >::iterator xobj = ((vector<myobject,allocator<myobject> >::iterator*) G__getstructoffset())->operator=(*(vector<myobject,allocator<myobject> >::iterator*) libp->para[0].ref);
         pobj = new vector<myobject,allocator<myobject> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__eventdict_429_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   vector<myobject,allocator<myobject> >::iterator* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new vector<myobject,allocator<myobject> >::iterator(*(vector<myobject,allocator<myobject> >::iterator*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<myobject,allocator<myobject> >::iterator G__TvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator;
static int G__eventdict_429_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<myobject,allocator<myobject> >::iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<myobject,allocator<myobject> >::iterator*) (soff+(sizeof(vector<myobject,allocator<myobject> >::iterator)*i)))->~G__TvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<myobject,allocator<myobject> >::iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<myobject,allocator<myobject> >::iterator*) (soff))->~G__TvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<mytrack,allocator<mytrack> > */
static int G__eventdict_432_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const mytrack& obj = ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->at((vector<mytrack,allocator<mytrack> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<mytrack,allocator<mytrack> >::iterator* pobj;
         vector<mytrack,allocator<mytrack> >::iterator xobj = ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->begin();
         pobj = new vector<mytrack,allocator<mytrack> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<mytrack,allocator<mytrack> >::iterator* pobj;
         vector<mytrack,allocator<mytrack> >::iterator xobj = ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->end();
         pobj = new vector<mytrack,allocator<mytrack> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<mytrack,allocator<mytrack> >::reverse_iterator* pobj;
         vector<mytrack,allocator<mytrack> >::reverse_iterator xobj = ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->rbegin();
         pobj = new vector<mytrack,allocator<mytrack> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<mytrack,allocator<mytrack> >::reverse_iterator* pobj;
         vector<mytrack,allocator<mytrack> >::reverse_iterator xobj = ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->rend();
         pobj = new vector<mytrack,allocator<mytrack> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->resize((vector<mytrack,allocator<mytrack> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->resize((vector<mytrack,allocator<mytrack> >::size_type) G__int(libp->para[0]), *((mytrack*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((const vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const mytrack& obj = ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->operator[]((vector<mytrack,allocator<mytrack> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<mytrack,allocator<mytrack> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<mytrack,allocator<mytrack> >[n];
     } else {
       p = new((void*) gvp) vector<mytrack,allocator<mytrack> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<mytrack,allocator<mytrack> >;
     } else {
       p = new((void*) gvp) vector<mytrack,allocator<mytrack> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<mytrack,allocator<mytrack> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<mytrack,allocator<mytrack> >((vector<mytrack,allocator<mytrack> >::size_type) G__int(libp->para[0]), *(mytrack*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<mytrack,allocator<mytrack> >((vector<mytrack,allocator<mytrack> >::size_type) G__int(libp->para[0]), *(mytrack*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<mytrack,allocator<mytrack> >((vector<mytrack,allocator<mytrack> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<mytrack,allocator<mytrack> >((vector<mytrack,allocator<mytrack> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<mytrack,allocator<mytrack> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<mytrack,allocator<mytrack> >(*(vector<mytrack,allocator<mytrack> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<mytrack,allocator<mytrack> >(*(vector<mytrack,allocator<mytrack> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<mytrack,allocator<mytrack> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<mytrack,allocator<mytrack> >(*((vector<mytrack,allocator<mytrack> >::const_iterator*) G__int(libp->para[0])), *((vector<mytrack,allocator<mytrack> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<mytrack,allocator<mytrack> >(*((vector<mytrack,allocator<mytrack> >::const_iterator*) G__int(libp->para[0])), *((vector<mytrack,allocator<mytrack> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<mytrack,allocator<mytrack> >& obj = ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->operator=(*(vector<mytrack,allocator<mytrack> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->reserve((vector<mytrack,allocator<mytrack> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const mytrack& obj = ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const mytrack& obj = ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->push_back(*(mytrack*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->swap(*(vector<mytrack,allocator<mytrack> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<mytrack,allocator<mytrack> >::iterator* pobj;
         vector<mytrack,allocator<mytrack> >::iterator xobj = ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->insert(*((vector<mytrack,allocator<mytrack> >::iterator*) G__int(libp->para[0])), *(mytrack*) libp->para[1].ref);
         pobj = new vector<mytrack,allocator<mytrack> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->insert(*((vector<mytrack,allocator<mytrack> >::iterator*) G__int(libp->para[0])), *((vector<mytrack,allocator<mytrack> >::const_iterator*) G__int(libp->para[1]))
, *((vector<mytrack,allocator<mytrack> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->insert(*((vector<mytrack,allocator<mytrack> >::iterator*) G__int(libp->para[0])), (vector<mytrack,allocator<mytrack> >::size_type) G__int(libp->para[1])
, *(mytrack*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->erase(*((vector<mytrack,allocator<mytrack> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->erase(*((vector<mytrack,allocator<mytrack> >::iterator*) G__int(libp->para[0])), *((vector<mytrack,allocator<mytrack> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_432_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<mytrack,allocator<mytrack> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<mytrack,allocator<mytrack> > G__TvectorlEmytrackcOallocatorlEmytrackgRsPgR;
static int G__eventdict_432_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<mytrack,allocator<mytrack> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<mytrack,allocator<mytrack> >*) (soff+(sizeof(vector<mytrack,allocator<mytrack> >)*i)))->~G__TvectorlEmytrackcOallocatorlEmytrackgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<mytrack,allocator<mytrack> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<mytrack,allocator<mytrack> >*) (soff))->~G__TvectorlEmytrackcOallocatorlEmytrackgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<mytrack,allocator<mytrack> >::iterator */
static int G__eventdict_433_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<mytrack,allocator<mytrack> >::iterator* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<mytrack,allocator<mytrack> >::iterator[n];
     } else {
       p = new((void*) gvp) vector<mytrack,allocator<mytrack> >::iterator[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<mytrack,allocator<mytrack> >::iterator;
     } else {
       p = new((void*) gvp) vector<mytrack,allocator<mytrack> >::iterator;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<mytrack,allocator<mytrack> >::iterator* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<mytrack,allocator<mytrack> >::iterator(libp->para[0].ref ? *(const vector<mytrack,allocator<mytrack> >::iterator::pointer*) libp->para[0].ref : *(const vector<mytrack,allocator<mytrack> >::iterator::pointer*) (&G__Mlong(libp->para[0])));
   } else {
     p = new((void*) gvp) vector<mytrack,allocator<mytrack> >::iterator(libp->para[0].ref ? *(const vector<mytrack,allocator<mytrack> >::iterator::pointer*) libp->para[0].ref : *(const vector<mytrack,allocator<mytrack> >::iterator::pointer*) (&G__Mlong(libp->para[0])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<mytrack,allocator<mytrack> >::iterator::reference obj = ((const vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator*();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<mytrack,allocator<mytrack> >::iterator& obj = ((vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator++();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<mytrack,allocator<mytrack> >::iterator* pobj;
         vector<mytrack,allocator<mytrack> >::iterator xobj = ((vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator++((int) G__int(libp->para[0]));
         pobj = new vector<mytrack,allocator<mytrack> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<mytrack,allocator<mytrack> >::iterator& obj = ((vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator--();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<mytrack,allocator<mytrack> >::iterator* pobj;
         vector<mytrack,allocator<mytrack> >::iterator xobj = ((vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator--((int) G__int(libp->para[0]));
         pobj = new vector<mytrack,allocator<mytrack> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<mytrack,allocator<mytrack> >::iterator::reference obj = ((const vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator[](*(vector<mytrack,allocator<mytrack> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<mytrack,allocator<mytrack> >::iterator& obj = ((vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator+=(*(vector<mytrack,allocator<mytrack> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<mytrack,allocator<mytrack> >::iterator* pobj;
         const vector<mytrack,allocator<mytrack> >::iterator xobj = ((const vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator+(*(vector<mytrack,allocator<mytrack> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         pobj = new vector<mytrack,allocator<mytrack> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<mytrack,allocator<mytrack> >::iterator& obj = ((vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator-=(*(vector<mytrack,allocator<mytrack> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<mytrack,allocator<mytrack> >::iterator* pobj;
         const vector<mytrack,allocator<mytrack> >::iterator xobj = ((const vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator-(*(vector<mytrack,allocator<mytrack> >::iterator::difference_type*) G__Longref(&libp->para[0]));
         pobj = new vector<mytrack,allocator<mytrack> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<mytrack,allocator<mytrack> >::iterator::pointer& obj = ((const vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->base();
         result7->ref = (long) (&obj);
         G__letint(result7, 'U', (long)obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict_433_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<mytrack,allocator<mytrack> >::iterator* pobj;
         vector<mytrack,allocator<mytrack> >::iterator xobj = ((vector<mytrack,allocator<mytrack> >::iterator*) G__getstructoffset())->operator=(*(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[0].ref);
         pobj = new vector<mytrack,allocator<mytrack> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__eventdict_433_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   vector<mytrack,allocator<mytrack> >::iterator* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new vector<mytrack,allocator<mytrack> >::iterator(*(vector<mytrack,allocator<mytrack> >::iterator*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<mytrack,allocator<mytrack> >::iterator G__TvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator;
static int G__eventdict_433_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<mytrack,allocator<mytrack> >::iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<mytrack,allocator<mytrack> >::iterator*) (soff+(sizeof(vector<mytrack,allocator<mytrack> >::iterator)*i)))->~G__TvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<mytrack,allocator<mytrack> >::iterator*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<mytrack,allocator<mytrack> >::iterator*) (soff))->~G__TvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */
static int G__eventdict__0_1541(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator==(*(vector<myobject,allocator<myobject> >::iterator*) libp->para[0].ref, *(vector<myobject,allocator<myobject> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1542(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator!=(*(vector<myobject,allocator<myobject> >::iterator*) libp->para[0].ref, *(vector<myobject,allocator<myobject> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1543(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<(*(vector<myobject,allocator<myobject> >::iterator*) libp->para[0].ref, *(vector<myobject,allocator<myobject> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1544(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>(*(vector<myobject,allocator<myobject> >::iterator*) libp->para[0].ref, *(vector<myobject,allocator<myobject> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1545(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<=(*(vector<myobject,allocator<myobject> >::iterator*) libp->para[0].ref, *(vector<myobject,allocator<myobject> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1546(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>=(*(vector<myobject,allocator<myobject> >::iterator*) libp->para[0].ref, *(vector<myobject,allocator<myobject> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1547(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) operator-(*(vector<myobject,allocator<myobject> >::iterator*) libp->para[0].ref, *(vector<myobject,allocator<myobject> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1548(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<myobject,allocator<myobject> >::iterator* pobj;
         const vector<myobject,allocator<myobject> >::iterator xobj = operator+((const vector<myobject,allocator<myobject> >::iterator::difference_type) G__int(libp->para[0]), *(vector<myobject,allocator<myobject> >::iterator*) libp->para[1].ref);
         pobj = new vector<myobject,allocator<myobject> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1609(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator==(*(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[0].ref, *(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1610(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator!=(*(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[0].ref, *(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1611(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<(*(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[0].ref, *(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1612(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>(*(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[0].ref, *(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1613(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator<=(*(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[0].ref, *(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1614(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) operator>=(*(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[0].ref, *(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1615(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 108, (long) operator-(*(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[0].ref, *(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[1].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__eventdict__0_1616(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<mytrack,allocator<mytrack> >::iterator* pobj;
         const vector<mytrack,allocator<mytrack> >::iterator xobj = operator+((const vector<mytrack,allocator<mytrack> >::iterator::difference_type) G__int(libp->para[0]), *(vector<mytrack,allocator<mytrack> >::iterator*) libp->para[1].ref);
         pobj = new vector<mytrack,allocator<mytrack> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}


/*********************************************************
* Member function Stub
*********************************************************/

/* mytrack */

/* myobject */

/* myevent */

/* vector<myobject,allocator<myobject> > */

/* vector<myobject,allocator<myobject> >::iterator */

/* vector<mytrack,allocator<mytrack> > */

/* vector<mytrack,allocator<mytrack> >::iterator */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfunceventdict {
 public:
  G__Sizep2memfunceventdict(): p(&G__Sizep2memfunceventdict::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfunceventdict::*p)();
};

size_t G__get_sizep2memfunceventdict()
{
  G__Sizep2memfunceventdict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceeventdict() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__eventdictLN_mytrack))) {
     mytrack *G__Lderived;
     G__Lderived=(mytrack*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__eventdictLN_mytrack),G__get_linked_tagnum(&G__eventdictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__eventdictLN_myobject))) {
     myobject *G__Lderived;
     G__Lderived=(myobject*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__eventdictLN_myobject),G__get_linked_tagnum(&G__eventdictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__eventdictLN_myevent))) {
     myevent *G__Lderived;
     G__Lderived=(myevent*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__eventdictLN_myevent),G__get_linked_tagnum(&G__eventdictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableeventdict() {

   /* Setting up typedef entry */
   G__search_typename2("Version_t",115,-1,0,-1);
   G__setnewtype(-1,"Class version identifier (short)",0);
   G__search_typename2("vector<TSchemaHelper>",117,G__get_linked_tagnum(&G__eventdictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__eventdictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<std::bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__eventdictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*>",117,G__get_linked_tagnum(&G__eventdictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long>",117,G__get_linked_tagnum(&G__eventdictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long,const TObject**>",117,G__get_linked_tagnum(&G__eventdictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<myobject>",117,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__eventdictLN_myobject),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__eventdictLN_myobject),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__eventdictLN_myobject),256,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__eventdictLN_myobject),1,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__eventdictLN_myobject),257,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__eventdictLN_myobject),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__eventdictLN_myobject),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__eventdictLN_myobject),1,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__eventdictLN_myobject),1,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<mytrack>",117,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__eventdictLN_mytrack),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__eventdictLN_mytrack),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__eventdictLN_mytrack),256,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__eventdictLN_mytrack),1,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__eventdictLN_mytrack),257,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__eventdictLN_mytrack),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__eventdictLN_mytrack),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__eventdictLN_mytrack),1,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__eventdictLN_mytrack),1,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",104,-1,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* mytrack */
static void G__setup_memvarmytrack(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__eventdictLN_mytrack));
   { mytrack *p; p=(mytrack*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->px)-(long)(p)),100,0,0,-1,-1,-1,1,"px=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->py)-(long)(p)),100,0,0,-1,-1,-1,1,"py=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pz)-(long)(p)),100,0,0,-1,-1,-1,1,"pz=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pt)-(long)(p)),100,0,0,-1,-1,-1,1,"pt=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->eta)-(long)(p)),100,0,0,-1,-1,-1,1,"eta=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->phi)-(long)(p)),100,0,0,-1,-1,-1,1,"phi=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->charge)-(long)(p)),100,0,0,-1,-1,-1,1,"charge=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->E)-(long)(p)),100,0,0,-1,-1,-1,1,"E=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ipx)-(long)(p)),100,0,0,-1,-1,-1,1,"ipx=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ipy)-(long)(p)),100,0,0,-1,-1,-1,1,"ipy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->iperr_x)-(long)(p)),100,0,0,-1,-1,-1,1,"iperr_x=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->iperr_y)-(long)(p)),100,0,0,-1,-1,-1,1,"iperr_y=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Vz)-(long)(p)),100,0,0,-1,-1,-1,1,"Vz=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Chi2)-(long)(p)),100,0,0,-1,-1,-1,1,"Chi2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Ndof)-(long)(p)),100,0,0,-1,-1,-1,1,"Ndof=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->VHits)-(long)(p)),100,0,0,-1,-1,-1,1,"VHits=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__eventdictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* myobject */
static void G__setup_memvarmyobject(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__eventdictLN_myobject));
   { myobject *p; p=(myobject*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->pt)-(long)(p)),100,0,0,-1,-1,-1,1,"pt=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->eta)-(long)(p)),100,0,0,-1,-1,-1,1,"eta=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->phi)-(long)(p)),100,0,0,-1,-1,-1,1,"phi=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->charge)-(long)(p)),100,0,0,-1,-1,-1,1,"charge=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->E)-(long)(p)),100,0,0,-1,-1,-1,1,"E=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->px)-(long)(p)),100,0,0,-1,-1,-1,1,"px=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->py)-(long)(p)),100,0,0,-1,-1,-1,1,"py=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pz)-(long)(p)),100,0,0,-1,-1,-1,1,"pz=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->corrpt)-(long)(p)),100,0,0,-1,-1,-1,1,"corrpt=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->corrpx)-(long)(p)),100,0,0,-1,-1,-1,1,"corrpx=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->corrpy)-(long)(p)),100,0,0,-1,-1,-1,1,"corrpy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->corrphi)-(long)(p)),100,0,0,-1,-1,-1,1,"corrphi=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DepositR03Ecal)-(long)(p)),100,0,0,-1,-1,-1,1,"DepositR03Ecal=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DepositR03Hcal)-(long)(p)),100,0,0,-1,-1,-1,1,"DepositR03Hcal=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DepositR03TrackerOfficial)-(long)(p)),100,0,0,-1,-1,-1,1,"DepositR03TrackerOfficial=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->alpha)-(long)(p)),100,0,0,-1,-1,-1,1,"alpha=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->discriminator)-(long)(p)),100,0,0,-1,-1,-1,1,"discriminator=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->HcalIsolation)-(long)(p)),100,0,0,-1,-1,-1,1,"HcalIsolation=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EcalIsolation)-(long)(p)),100,0,0,-1,-1,-1,1,"EcalIsolation=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrackerIsolation)-(long)(p)),100,0,0,-1,-1,-1,1,"TrackerIsolation=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EcalJurassicIsolation)-(long)(p)),100,0,0,-1,-1,-1,1,"EcalJurassicIsolation=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->classification)-(long)(p)),105,0,0,-1,-1,-1,1,"classification=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->HoverE)-(long)(p)),100,0,0,-1,-1,-1,1,"HoverE=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EseedPout)-(long)(p)),100,0,0,-1,-1,-1,1,"EseedPout=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dEta)-(long)(p)),100,0,0,-1,-1,-1,1,"dEta=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dPhi)-(long)(p)),100,0,0,-1,-1,-1,1,"dPhi=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->s9s25)-(long)(p)),100,0,0,-1,-1,-1,1,"s9s25=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->sigmaEtaEta)-(long)(p)),100,0,0,-1,-1,-1,1,"sigmaEtaEta=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->eidTight)-(long)(p)),103,0,0,-1,-1,-1,1,"eidTight=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GlobalMuonPromptTight)-(long)(p)),103,0,0,-1,-1,-1,1,"GlobalMuonPromptTight=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TMOneStationLoose)-(long)(p)),103,0,0,-1,-1,-1,1,"TMOneStationLoose=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TM2DCompatibilityLoose)-(long)(p)),103,0,0,-1,-1,-1,1,"TM2DCompatibilityLoose=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->name)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_string),-1,-1,1,"name=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__eventdictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* myevent */
static void G__setup_memvarmyevent(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__eventdictLN_myevent));
   { myevent *p; p=(myevent*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->RecJets)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"RecJets=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RecPFJetsIC5)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"RecPFJetsIC5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RecPFJetsSC5)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"RecPFJetsSC5=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PreSelectedElectrons)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"PreSelectedElectrons=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PreSelectedMuons)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"PreSelectedMuons=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RecMet)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"RecMet=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RecPFMet)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"RecPFMet=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GenMet)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"GenMet=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GenJets)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"GenJets=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->MCBjets)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"MCBjets=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->MCNus)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"MCNus=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GenParticle)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"GenParticle=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Vertex)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),G__defined_typename("vector<myobject>"),-1,1,"Vertex=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->AllTracks)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR),G__defined_typename("vector<mytrack>"),-1,1,"AllTracks=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PDF_weights1)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,1,"PDF_weights1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PDF_weights2)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,1,"PDF_weights2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PDF_weights3)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,1,"PDF_weights3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PDF_weights4)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,1,"PDF_weights4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->product_central_1)-(long)(p)),100,0,0,-1,-1,-1,1,"product_central_1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->product_central_2)-(long)(p)),100,0,0,-1,-1,-1,1,"product_central_2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->product_central_3)-(long)(p)),100,0,0,-1,-1,-1,1,"product_central_3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->product_central_4)-(long)(p)),100,0,0,-1,-1,-1,1,"product_central_4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->x_1)-(long)(p)),100,0,0,-1,-1,-1,1,"x_1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->x_2)-(long)(p)),100,0,0,-1,-1,-1,1,"x_2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Q_scale)-(long)(p)),100,0,0,-1,-1,-1,1,"Q_scale=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->f1)-(long)(p)),105,0,0,-1,-1,-1,1,"f1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->f2)-(long)(p)),105,0,0,-1,-1,-1,1,"f2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pdf_1)-(long)(p)),100,0,0,-1,-1,-1,1,"pdf_1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pdf_2)-(long)(p)),100,0,0,-1,-1,-1,1,"pdf_2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->HLT)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__eventdictLN_maplEstringcOintcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOintgRsPgRsPgR),G__defined_typename("map<string,int>"),-1,1,"HLT=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->weight)-(long)(p)),100,0,0,-1,-1,-1,1,"weight=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->KFactor)-(long)(p)),100,0,0,-1,-1,-1,1,"KFactor=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ProcessId)-(long)(p)),105,0,0,-1,-1,-1,1,"ProcessId=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PtHat)-(long)(p)),100,0,0,-1,-1,-1,1,"PtHat=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PreselectionMarker)-(long)(p)),103,0,0,-1,-1,-1,1,"PreselectionMarker=",0,(char*)NULL);
   G__memvar_setup((void*)0,85,0,0,G__get_linked_tagnum(&G__eventdictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<myobject,allocator<myobject> > */
static void G__setup_memvarvectorlEmyobjectcOallocatorlEmyobjectgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   { vector<myobject,allocator<myobject> > *p; p=(vector<myobject,allocator<myobject> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<myobject,allocator<myobject> >::iterator */
static void G__setup_memvarvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator));
   { vector<myobject,allocator<myobject> >::iterator *p; p=(vector<myobject,allocator<myobject> >::iterator*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<mytrack,allocator<mytrack> > */
static void G__setup_memvarvectorlEmytrackcOallocatorlEmytrackgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   { vector<mytrack,allocator<mytrack> > *p; p=(vector<mytrack,allocator<mytrack> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<mytrack,allocator<mytrack> >::iterator */
static void G__setup_memvarvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator));
   { vector<mytrack,allocator<mytrack> >::iterator *p; p=(vector<mytrack,allocator<mytrack> >::iterator*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvareventdict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncmytrack(void) {
   /* mytrack */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__eventdictLN_mytrack));
   G__memfunc_setup("mytrack",763,G__eventdict_189_0_1, 105, G__get_linked_tagnum(&G__eventdictLN_mytrack), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__eventdict_189_0_2, 85, G__get_linked_tagnum(&G__eventdictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (TClass* (*)())(&mytrack::Class), 0);
   G__memfunc_setup("Class_Name",982,G__eventdict_189_0_3, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) (const char* (*)())(&mytrack::Class_Name), 0);
   G__memfunc_setup("Class_Version",1339,G__eventdict_189_0_4, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (Version_t (*)())(&mytrack::Class_Version), 0);
   G__memfunc_setup("Dictionary",1046,G__eventdict_189_0_5, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (void (*)())(&mytrack::Dictionary), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__eventdictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__eventdict_189_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__eventdict_189_0_10, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) (const char* (*)())(&mytrack::DeclFileName), 0);
   G__memfunc_setup("ImplFileLine",1178,G__eventdict_189_0_11, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (int (*)())(&mytrack::ImplFileLine), 0);
   G__memfunc_setup("ImplFileName",1171,G__eventdict_189_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) (const char* (*)())(&mytrack::ImplFileName), 0);
   G__memfunc_setup("DeclFileLine",1152,G__eventdict_189_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (int (*)())(&mytrack::DeclFileLine), 0);
   // automatic copy constructor
   G__memfunc_setup("mytrack", 763, G__eventdict_189_0_14, (int) ('i'), G__get_linked_tagnum(&G__eventdictLN_mytrack), -1, 0, 1, 1, 1, 0, "u 'mytrack' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~mytrack", 889, G__eventdict_189_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__eventdict_189_0_16, (int) ('u'), G__get_linked_tagnum(&G__eventdictLN_mytrack), -1, 1, 1, 1, 1, 0, "u 'mytrack' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncmyobject(void) {
   /* myobject */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__eventdictLN_myobject));
   G__memfunc_setup("myobject",861,G__eventdict_190_0_1, 105, G__get_linked_tagnum(&G__eventdictLN_myobject), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__eventdict_190_0_2, 85, G__get_linked_tagnum(&G__eventdictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (TClass* (*)())(&myobject::Class), 0);
   G__memfunc_setup("Class_Name",982,G__eventdict_190_0_3, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) (const char* (*)())(&myobject::Class_Name), 0);
   G__memfunc_setup("Class_Version",1339,G__eventdict_190_0_4, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (Version_t (*)())(&myobject::Class_Version), 0);
   G__memfunc_setup("Dictionary",1046,G__eventdict_190_0_5, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (void (*)())(&myobject::Dictionary), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__eventdictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__eventdict_190_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__eventdict_190_0_10, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) (const char* (*)())(&myobject::DeclFileName), 0);
   G__memfunc_setup("ImplFileLine",1178,G__eventdict_190_0_11, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (int (*)())(&myobject::ImplFileLine), 0);
   G__memfunc_setup("ImplFileName",1171,G__eventdict_190_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) (const char* (*)())(&myobject::ImplFileName), 0);
   G__memfunc_setup("DeclFileLine",1152,G__eventdict_190_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (int (*)())(&myobject::DeclFileLine), 0);
   // automatic copy constructor
   G__memfunc_setup("myobject", 861, G__eventdict_190_0_14, (int) ('i'), G__get_linked_tagnum(&G__eventdictLN_myobject), -1, 0, 1, 1, 1, 0, "u 'myobject' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~myobject", 987, G__eventdict_190_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__eventdict_190_0_16, (int) ('u'), G__get_linked_tagnum(&G__eventdictLN_myobject), -1, 1, 1, 1, 1, 0, "u 'myobject' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncmyevent(void) {
   /* myevent */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__eventdictLN_myevent));
   G__memfunc_setup("myevent",776,G__eventdict_426_0_1, 105, G__get_linked_tagnum(&G__eventdictLN_myevent), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Class",502,G__eventdict_426_0_2, 85, G__get_linked_tagnum(&G__eventdictLN_TClass), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (TClass* (*)())(&myevent::Class), 0);
   G__memfunc_setup("Class_Name",982,G__eventdict_426_0_3, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) (const char* (*)())(&myevent::Class_Name), 0);
   G__memfunc_setup("Class_Version",1339,G__eventdict_426_0_4, 115, -1, G__defined_typename("Version_t"), 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (Version_t (*)())(&myevent::Class_Version), 0);
   G__memfunc_setup("Dictionary",1046,G__eventdict_426_0_5, 121, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (void (*)())(&myevent::Dictionary), 0);
   G__memfunc_setup("IsA",253,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__eventdictLN_TClass), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("ShowMembers",1132,(G__InterfaceMethod) NULL,121, -1, -1, 0, 2, 1, 1, 0, 
"u 'TMemberInspector' - 1 - insp C - - 0 - parent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Streamer",835,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("StreamerNVirtual",1656,G__eventdict_426_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TBuffer' - 1 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DeclFileName",1145,G__eventdict_426_0_10, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) (const char* (*)())(&myevent::DeclFileName), 0);
   G__memfunc_setup("ImplFileLine",1178,G__eventdict_426_0_11, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (int (*)())(&myevent::ImplFileLine), 0);
   G__memfunc_setup("ImplFileName",1171,G__eventdict_426_0_12, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) (const char* (*)())(&myevent::ImplFileName), 0);
   G__memfunc_setup("DeclFileLine",1152,G__eventdict_426_0_13, 105, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) (int (*)())(&myevent::DeclFileLine), 0);
   // automatic copy constructor
   G__memfunc_setup("myevent", 776, G__eventdict_426_0_14, (int) ('i'), G__get_linked_tagnum(&G__eventdictLN_myevent), -1, 0, 1, 1, 1, 0, "u 'myevent' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~myevent", 902, G__eventdict_426_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__eventdict_426_0_16, (int) ('u'), G__get_linked_tagnum(&G__eventdictLN_myevent), -1, 1, 1, 1, 1, 0, "u 'myevent' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEmyobjectcOallocatorlEmyobjectgRsPgR(void) {
   /* vector<myobject,allocator<myobject> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR));
   G__memfunc_setup("at",213,G__eventdict_428_0_1, 117, G__get_linked_tagnum(&G__eventdictLN_myobject), -1, 1, 1, 1, 1, 0, "h - 'vector<myobject,allocator<myobject> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__eventdict_428_0_2, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__eventdict_428_0_3, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__eventdict_428_0_4, 117, G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiteratorgR), G__defined_typename("vector<myobject,allocator<myobject> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__eventdict_428_0_5, 117, G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiteratorgR), G__defined_typename("vector<myobject,allocator<myobject> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__eventdict_428_0_6, 104, -1, G__defined_typename("vector<myobject,allocator<myobject> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__eventdict_428_0_7, 104, -1, G__defined_typename("vector<myobject,allocator<myobject> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__eventdict_428_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<myobject,allocator<myobject> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__eventdict_428_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - 'vector<myobject,allocator<myobject> >::size_type' 0 - sz u 'myobject' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__eventdict_428_0_10, 104, -1, G__defined_typename("vector<myobject,allocator<myobject> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__eventdict_428_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__eventdict_428_0_12, 117, G__get_linked_tagnum(&G__eventdictLN_myobject), -1, 1, 1, 1, 1, 0, "h - 'vector<myobject,allocator<myobject> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<myobject,allocator<myobject> >",3662,G__eventdict_428_0_13, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<myobject,allocator<myobject> >",3662,G__eventdict_428_0_14, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR), -1, 0, 2, 1, 1, 0, 
"h - 'vector<myobject,allocator<myobject> >::size_type' 0 - n u 'myobject' - 11 'myobject()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<myobject,allocator<myobject> >",3662,G__eventdict_428_0_15, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<myobject,allocator<myobject> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<myobject,allocator<myobject> >",3662,G__eventdict_428_0_16, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<myobject,allocator<myobject> >::iterator' 'vector<myobject,allocator<myobject> >::const_iterator' 10 - first u 'vector<myobject,allocator<myobject> >::iterator' 'vector<myobject,allocator<myobject> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__eventdict_428_0_17, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<myobject,allocator<myobject> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__eventdict_428_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<myobject,allocator<myobject> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__eventdict_428_0_19, 117, G__get_linked_tagnum(&G__eventdictLN_myobject), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__eventdict_428_0_20, 117, G__get_linked_tagnum(&G__eventdictLN_myobject), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__eventdict_428_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'myobject' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__eventdict_428_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<myobject,allocator<myobject> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__eventdict_428_0_23, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<myobject,allocator<myobject> >::iterator' - 0 - position u 'myobject' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__eventdict_428_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<myobject,allocator<myobject> >::iterator' - 0 - position u 'vector<myobject,allocator<myobject> >::iterator' 'vector<myobject,allocator<myobject> >::const_iterator' 10 - first "
"u 'vector<myobject,allocator<myobject> >::iterator' 'vector<myobject,allocator<myobject> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__eventdict_428_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<myobject,allocator<myobject> >::iterator' - 0 - position h - 'vector<myobject,allocator<myobject> >::size_type' 0 - n "
"u 'myobject' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__eventdict_428_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__eventdict_428_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<myobject,allocator<myobject> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__eventdict_428_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<myobject,allocator<myobject> >::iterator' - 0 - first u 'vector<myobject,allocator<myobject> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__eventdict_428_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<myobject,allocator<myobject> >", 3788, G__eventdict_428_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator(void) {
   /* vector<myobject,allocator<myobject> >::iterator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator));
   G__memfunc_setup("iterator",874,G__eventdict_429_0_1, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("iterator",874,G__eventdict_429_0_2, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 1, 5, 1, 0, "U 'myobject' 'vector<myobject,allocator<myobject> >::iterator::pointer' 11 - __i", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator*",918,G__eventdict_429_0_3, 117, G__get_linked_tagnum(&G__eventdictLN_myobject), G__defined_typename("vector<myobject,allocator<myobject> >::iterator::reference"), 1, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__eventdict_429_0_4, 85, G__get_linked_tagnum(&G__eventdictLN_myobject), G__defined_typename("vector<myobject,allocator<myobject> >::iterator::pointer"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__eventdict_429_0_5, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__eventdict_429_0_6, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__eventdict_429_0_7, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__eventdict_429_0_8, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__eventdict_429_0_9, 117, G__get_linked_tagnum(&G__eventdictLN_myobject), G__defined_typename("vector<myobject,allocator<myobject> >::iterator::reference"), 1, 1, 1, 1, 8, "l - 'vector<myobject,allocator<myobject> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+=",980,G__eventdict_429_0_10, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 1, 1, 1, 1, 0, "l - 'vector<myobject,allocator<myobject> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+",919,G__eventdict_429_0_11, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 8, "l - 'vector<myobject,allocator<myobject> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-=",982,G__eventdict_429_0_12, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 1, 1, 1, 1, 0, "l - 'vector<myobject,allocator<myobject> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-",921,G__eventdict_429_0_13, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 8, "l - 'vector<myobject,allocator<myobject> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("base",411,G__eventdict_429_0_14, 85, G__get_linked_tagnum(&G__eventdictLN_myobject), G__defined_typename("vector<myobject,allocator<myobject> >::iterator::pointer"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__eventdict_429_0_15, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'vector<myobject,allocator<myobject> >::iterator' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("iterator", 874, G__eventdict_429_0_16, (int) ('i'), G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'vector<myobject,allocator<myobject> >::iterator' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~iterator", 1000, G__eventdict_429_0_17, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEmytrackcOallocatorlEmytrackgRsPgR(void) {
   /* vector<mytrack,allocator<mytrack> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR));
   G__memfunc_setup("at",213,G__eventdict_432_0_1, 117, G__get_linked_tagnum(&G__eventdictLN_mytrack), -1, 1, 1, 1, 1, 0, "h - 'vector<mytrack,allocator<mytrack> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__eventdict_432_0_2, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__eventdict_432_0_3, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__eventdict_432_0_4, 117, G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiteratorgR), G__defined_typename("vector<mytrack,allocator<mytrack> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__eventdict_432_0_5, 117, G__get_linked_tagnum(&G__eventdictLN_reverse_iteratorlEvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiteratorgR), G__defined_typename("vector<mytrack,allocator<mytrack> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__eventdict_432_0_6, 104, -1, G__defined_typename("vector<mytrack,allocator<mytrack> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__eventdict_432_0_7, 104, -1, G__defined_typename("vector<mytrack,allocator<mytrack> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__eventdict_432_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<mytrack,allocator<mytrack> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__eventdict_432_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"h - 'vector<mytrack,allocator<mytrack> >::size_type' 0 - sz u 'mytrack' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__eventdict_432_0_10, 104, -1, G__defined_typename("vector<mytrack,allocator<mytrack> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__eventdict_432_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__eventdict_432_0_12, 117, G__get_linked_tagnum(&G__eventdictLN_mytrack), -1, 1, 1, 1, 1, 0, "h - 'vector<mytrack,allocator<mytrack> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<mytrack,allocator<mytrack> >",3466,G__eventdict_432_0_13, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<mytrack,allocator<mytrack> >",3466,G__eventdict_432_0_14, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR), -1, 0, 2, 1, 1, 0, 
"h - 'vector<mytrack,allocator<mytrack> >::size_type' 0 - n u 'mytrack' - 11 'mytrack()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<mytrack,allocator<mytrack> >",3466,G__eventdict_432_0_15, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<mytrack,allocator<mytrack> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<mytrack,allocator<mytrack> >",3466,G__eventdict_432_0_16, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' 'vector<mytrack,allocator<mytrack> >::const_iterator' 10 - first u 'vector<mytrack,allocator<mytrack> >::iterator' 'vector<mytrack,allocator<mytrack> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__eventdict_432_0_17, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<mytrack,allocator<mytrack> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__eventdict_432_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'vector<mytrack,allocator<mytrack> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__eventdict_432_0_19, 117, G__get_linked_tagnum(&G__eventdictLN_mytrack), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__eventdict_432_0_20, 117, G__get_linked_tagnum(&G__eventdictLN_mytrack), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__eventdict_432_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'mytrack' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__eventdict_432_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<mytrack,allocator<mytrack> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__eventdict_432_0_23, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' - 0 - position u 'mytrack' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__eventdict_432_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' - 0 - position u 'vector<mytrack,allocator<mytrack> >::iterator' 'vector<mytrack,allocator<mytrack> >::const_iterator' 10 - first "
"u 'vector<mytrack,allocator<mytrack> >::iterator' 'vector<mytrack,allocator<mytrack> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__eventdict_432_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' - 0 - position h - 'vector<mytrack,allocator<mytrack> >::size_type' 0 - n "
"u 'mytrack' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__eventdict_432_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__eventdict_432_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<mytrack,allocator<mytrack> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__eventdict_432_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' - 0 - first u 'vector<mytrack,allocator<mytrack> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__eventdict_432_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<mytrack,allocator<mytrack> >", 3592, G__eventdict_432_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator(void) {
   /* vector<mytrack,allocator<mytrack> >::iterator */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator));
   G__memfunc_setup("iterator",874,G__eventdict_433_0_1, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("iterator",874,G__eventdict_433_0_2, 105, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 1, 5, 1, 0, "U 'mytrack' 'vector<mytrack,allocator<mytrack> >::iterator::pointer' 11 - __i", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator*",918,G__eventdict_433_0_3, 117, G__get_linked_tagnum(&G__eventdictLN_mytrack), G__defined_typename("vector<mytrack,allocator<mytrack> >::iterator::reference"), 1, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__eventdict_433_0_4, 85, G__get_linked_tagnum(&G__eventdictLN_mytrack), G__defined_typename("vector<mytrack,allocator<mytrack> >::iterator::pointer"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__eventdict_433_0_5, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator++",962,G__eventdict_433_0_6, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__eventdict_433_0_7, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator--",966,G__eventdict_433_0_8, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "i - - 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__eventdict_433_0_9, 117, G__get_linked_tagnum(&G__eventdictLN_mytrack), G__defined_typename("vector<mytrack,allocator<mytrack> >::iterator::reference"), 1, 1, 1, 1, 8, "l - 'vector<mytrack,allocator<mytrack> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+=",980,G__eventdict_433_0_10, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 1, 1, 1, 1, 0, "l - 'vector<mytrack,allocator<mytrack> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+",919,G__eventdict_433_0_11, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 8, "l - 'vector<mytrack,allocator<mytrack> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-=",982,G__eventdict_433_0_12, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 1, 1, 1, 1, 0, "l - 'vector<mytrack,allocator<mytrack> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-",921,G__eventdict_433_0_13, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 8, "l - 'vector<mytrack,allocator<mytrack> >::iterator::difference_type' 11 - __n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("base",411,G__eventdict_433_0_14, 85, G__get_linked_tagnum(&G__eventdictLN_mytrack), G__defined_typename("vector<mytrack,allocator<mytrack> >::iterator::pointer"), 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__eventdict_433_0_15, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("iterator", 874, G__eventdict_433_0_16, (int) ('i'), G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~iterator", 1000, G__eventdict_433_0_17, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfunceventdict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globaleventdict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
   G__memfunc_setup("operator==", 998, G__eventdict__0_1541, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<myobject,allocator<myobject> >::iterator' - 11 - x u 'vector<myobject,allocator<myobject> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator!=", 970, G__eventdict__0_1542, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<myobject,allocator<myobject> >::iterator' - 11 - x u 'vector<myobject,allocator<myobject> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<", 936, G__eventdict__0_1543, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<myobject,allocator<myobject> >::iterator' - 11 - x u 'vector<myobject,allocator<myobject> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>", 938, G__eventdict__0_1544, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<myobject,allocator<myobject> >::iterator' - 11 - x u 'vector<myobject,allocator<myobject> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<=", 997, G__eventdict__0_1545, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<myobject,allocator<myobject> >::iterator' - 11 - x u 'vector<myobject,allocator<myobject> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>=", 999, G__eventdict__0_1546, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<myobject,allocator<myobject> >::iterator' - 11 - x u 'vector<myobject,allocator<myobject> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator-", 921, G__eventdict__0_1547, 108, -1, G__defined_typename("difference_type"), 0, 2, 1, 1, 8, 
"u 'vector<myobject,allocator<myobject> >::iterator' - 11 - x u 'vector<myobject,allocator<myobject> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator+", 919, G__eventdict__0_1548, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 8, 
"l - 'difference_type' 10 - x u 'vector<myobject,allocator<myobject> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator==", 998, G__eventdict__0_1609, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - x u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator!=", 970, G__eventdict__0_1610, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - x u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<", 936, G__eventdict__0_1611, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - x u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>", 938, G__eventdict__0_1612, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - x u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator<=", 997, G__eventdict__0_1613, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - x u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator>=", 999, G__eventdict__0_1614, 103, -1, -1, 0, 2, 1, 1, 8, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - x u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator-", 921, G__eventdict__0_1615, 108, -1, G__defined_typename("difference_type"), 0, 2, 1, 1, 8, 
"u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - x u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("operator+", 919, G__eventdict__0_1616, 117, G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 8, 
"l - 'difference_type' 10 - x u 'vector<mytrack,allocator<mytrack> >::iterator' - 11 - y", (char*) NULL
, (void*) NULL, 0);
}

static void G__cpp_setup_func16() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funceventdict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__eventdictLN_TClass = { "TClass" , 99 , -1 };
G__linked_taginfo G__eventdictLN_TBuffer = { "TBuffer" , 99 , -1 };
G__linked_taginfo G__eventdictLN_TMemberInspector = { "TMemberInspector" , 99 , -1 };
G__linked_taginfo G__eventdictLN_TObject = { "TObject" , 99 , -1 };
G__linked_taginfo G__eventdictLN_vectorlEdoublecOallocatorlEdoublegRsPgR = { "vector<double,allocator<double> >" , 99 , -1 };
G__linked_taginfo G__eventdictLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__eventdictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__eventdictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__eventdictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR = { "iterator<bidirectional_iterator_tag,TObject*,long,const TObject**,const TObject*&>" , 115 , -1 };
G__linked_taginfo G__eventdictLN_mytrack = { "mytrack" , 99 , -1 };
G__linked_taginfo G__eventdictLN_myobject = { "myobject" , 99 , -1 };
G__linked_taginfo G__eventdictLN_maplEstringcOintcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOintgRsPgRsPgR = { "map<string,int,less<string>,allocator<pair<const string,int> > >" , 99 , -1 };
G__linked_taginfo G__eventdictLN_myevent = { "myevent" , 99 , -1 };
G__linked_taginfo G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR = { "vector<myobject,allocator<myobject> >" , 99 , -1 };
G__linked_taginfo G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator = { "vector<myobject,allocator<myobject> >::iterator" , 99 , -1 };
G__linked_taginfo G__eventdictLN_reverse_iteratorlEvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<myobject,allocator<myobject> >::iterator>" , 99 , -1 };
G__linked_taginfo G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR = { "vector<mytrack,allocator<mytrack> >" , 99 , -1 };
G__linked_taginfo G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator = { "vector<mytrack,allocator<mytrack> >::iterator" , 99 , -1 };
G__linked_taginfo G__eventdictLN_reverse_iteratorlEvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<mytrack,allocator<mytrack> >::iterator>" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableeventdict() {
  G__eventdictLN_TClass.tagnum = -1 ;
  G__eventdictLN_TBuffer.tagnum = -1 ;
  G__eventdictLN_TMemberInspector.tagnum = -1 ;
  G__eventdictLN_TObject.tagnum = -1 ;
  G__eventdictLN_vectorlEdoublecOallocatorlEdoublegRsPgR.tagnum = -1 ;
  G__eventdictLN_string.tagnum = -1 ;
  G__eventdictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__eventdictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__eventdictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR.tagnum = -1 ;
  G__eventdictLN_mytrack.tagnum = -1 ;
  G__eventdictLN_myobject.tagnum = -1 ;
  G__eventdictLN_maplEstringcOintcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOintgRsPgRsPgR.tagnum = -1 ;
  G__eventdictLN_myevent.tagnum = -1 ;
  G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR.tagnum = -1 ;
  G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator.tagnum = -1 ;
  G__eventdictLN_reverse_iteratorlEvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR.tagnum = -1 ;
  G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator.tagnum = -1 ;
  G__eventdictLN_reverse_iteratorlEvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiteratorgR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableeventdict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__eventdictLN_TClass);
   G__get_linked_tagnum_fwd(&G__eventdictLN_TBuffer);
   G__get_linked_tagnum_fwd(&G__eventdictLN_TMemberInspector);
   G__get_linked_tagnum_fwd(&G__eventdictLN_TObject);
   G__get_linked_tagnum_fwd(&G__eventdictLN_vectorlEdoublecOallocatorlEdoublegRsPgR);
   G__get_linked_tagnum_fwd(&G__eventdictLN_string);
   G__get_linked_tagnum_fwd(&G__eventdictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__eventdictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__eventdictLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__eventdictLN_mytrack),sizeof(mytrack),-1,292096,(char*)NULL,G__setup_memvarmytrack,G__setup_memfuncmytrack);
   G__tagtable_setup(G__get_linked_tagnum(&G__eventdictLN_myobject),sizeof(myobject),-1,292096,(char*)NULL,G__setup_memvarmyobject,G__setup_memfuncmyobject);
   G__get_linked_tagnum_fwd(&G__eventdictLN_maplEstringcOintcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOintgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__eventdictLN_myevent),sizeof(myevent),-1,292096,(char*)NULL,G__setup_memvarmyevent,G__setup_memfuncmyevent);
   G__tagtable_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgR),sizeof(vector<myobject,allocator<myobject> >),-1,36608,(char*)NULL,G__setup_memvarvectorlEmyobjectcOallocatorlEmyobjectgRsPgR,G__setup_memfuncvectorlEmyobjectcOallocatorlEmyobjectgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator),sizeof(vector<myobject,allocator<myobject> >::iterator),-1,35072,(char*)NULL,G__setup_memvarvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator,G__setup_memfuncvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__eventdictLN_reverse_iteratorlEvectorlEmyobjectcOallocatorlEmyobjectgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgR),sizeof(vector<mytrack,allocator<mytrack> >),-1,36608,(char*)NULL,G__setup_memvarvectorlEmytrackcOallocatorlEmytrackgRsPgR,G__setup_memfuncvectorlEmytrackcOallocatorlEmytrackgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__eventdictLN_vectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator),sizeof(vector<mytrack,allocator<mytrack> >::iterator),-1,35072,(char*)NULL,G__setup_memvarvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator,G__setup_memfuncvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__eventdictLN_reverse_iteratorlEvectorlEmytrackcOallocatorlEmytrackgRsPgRcLcLiteratorgR);
}
extern "C" void G__cpp_setupeventdict(void) {
  G__check_setup_version(30051515,"G__cpp_setupeventdict()");
  G__set_cpp_environmenteventdict();
  G__cpp_setup_tagtableeventdict();

  G__cpp_setup_inheritanceeventdict();

  G__cpp_setup_typetableeventdict();

  G__cpp_setup_memvareventdict();

  G__cpp_setup_memfunceventdict();
  G__cpp_setup_globaleventdict();
  G__cpp_setup_funceventdict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfunceventdict();
  return;
}
class G__cpp_setup_initeventdict {
  public:
    G__cpp_setup_initeventdict() { G__add_setup_func("eventdict",(G__incsetup)(&G__cpp_setupeventdict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initeventdict() { G__remove_setup_func("eventdict"); }
};
G__cpp_setup_initeventdict G__cpp_setup_initializereventdict;

